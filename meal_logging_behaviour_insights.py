# -*- coding: utf-8 -*-
"""Meal_Logging_Behaviour_Insights.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E4gWUrY2wOdiiaO0qIjfADo37XGmavSC
"""

# Importing required libraries

import json
import pandas as pd
from datetime import datetime
import matplotlib.pyplot as plt
import nltk
from nltk.corpus import wordnet
from nltk.corpus import stopwords
from nltk.sentiment import SentimentIntensityAnalyzer
nltk.download('wordnet')
nltk.download('stopwords')
nltk.download('vader_lexicon')
from wordcloud import WordCloud
import re
from collections import Counter

# Loading the data

file = open("data.json","r")

data = json.load(file)

data_df = pd.DataFrame(data, columns=['user_id','log_time','description'])

#724 rows x 3cols

# Converting string to datetime
data_df['log_time'] = pd.to_datetime(data_df['log_time'])

# Adding columns for date, time, month and hour for each record
data_df['date'] = data_df['log_time'].dt.date
data_df['time'] = data_df['log_time'].dt.time
data_df['hour'] = data_df['log_time'].dt.hour
data_df['month'] = data_df['log_time'].dt.month

# Splitting description, convert to lowercase into words and remove stopwords
data_df['description'] = list(map(lambda desc: desc.lower(), data_df['description']))

def remove_stopwords(desc):
    sw = set(stopwords.words('english'))
    sw.update(["plate","bowl","spoon","fork","table","cup","kitchen"])
    final_words = [word for word in desc.split() if word.lower() not in sw]
    return ' '.join(final_words)

data_df['new_desc'] = data_df['description'].apply(remove_stopwords)
wc = ' '.join(desc for desc in data_df['new_desc'])
data_df['new_desc'] = list(map(lambda desc: desc.split(), data_df['new_desc']))

# WordCloud to display the most frequent words using matplotlib

unique_wc = set()

for desc in data_df['new_desc']:
  for word in desc:
    unique_wc.add(word)

wordcloud = WordCloud(width=800, height=400, background_color='white', max_words=(len(unique_wc))).generate(wc)

plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.show()

# Extracting words related only to food but not to cultery

def is_food_related(word):
    synsets = wordnet.synsets(word)
    food = False
    cutlery = False
    for synset in synsets:
        if 'food' in synset.definition().lower():
          food = True
        if 'cutlery' in synset.definition().lower():
          cutlery = True

    return food and not(cutlery)

food_related_words = []
for desc in data_df['new_desc']:
  for word in desc:
    if is_food_related(word):
      food_related_words.append(word)


frwstr = ' '.join(food_related_words)
frws = set(food_related_words)

# WordCloud to show only the food-related words

wordcloud = WordCloud(width=800, height=400, background_color='white', max_words=(len(frws))).generate(frwstr)

plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')  # Turn off axis labels
plt.show()

# Printing the most frequent words

words = re.findall(r'\b\w+\b', frwstr.lower())

word_counts = Counter(words)

for word, count in word_counts.most_common(5):  #top five
    print(f"{word}: {count} times")

# Categorizing every entry as Breakfast, Lunch or Dinner

def categorize_meal(hr):
    if 4 <= hr < 11:
        return 'breakfast'
    elif 11 <= hr < 18:
        return 'lunch'
    else:
        return 'dinner'

data_df['meal_type'] = data_df['hour'].apply(categorize_meal)

meal_types = ['breakfast', 'lunch', 'dinner']
for meal in meal_types:
    meal_df = data_df[data_df['meal_type'] == meal]
    print(meal+" logs:")
    print(meal_df['hour'].value_counts().sort_index())

# Sentiment analysis to understand how the user feels while giving the a particular meal entry

def get_happiness_score(desc):
    sid = SentimentIntensityAnalyzer()
    sentiment_scores = sid.polarity_scores(desc)
    return sentiment_scores['compound']

def rank_entries(df):
    df['SentimentScore'] = df['description'].apply(lambda x: get_happiness_score(x))
    df = df.sort_values(by='SentimentScore', ascending=False).reset_index(drop=True)
    df['Rank'] = df.index + 1
    return df[['description', 'Rank','SentimentScore', 'user_id', 'date','meal_type']]


ranked_df = rank_entries(data_df)

positive_sentiment = ranked_df[ranked_df['SentimentScore'] >= 0]
print(positive_sentiment)

negative_sentiment = ranked_df[ranked_df['SentimentScore'] < 0]
print(negative_sentiment)

# Calculating monthly average Mood Score for each user
ranked_df['month'] = pd.to_datetime(ranked_df['date']).dt.month

monthly_avg_mood = ranked_df.groupby(['user_id', 'month'])['SentimentScore'].mean().reset_index()

# Plot monthly average Mood Score for each user
users = monthly_avg_mood['user_id'].unique()
num_users = len(users)
num_cols = 3
num_rows = -(-num_users // num_cols)

fig, axes = plt.subplots(num_rows, num_cols, figsize=(15, 5*num_rows))

# Scaling the Y-Axis
y_min = monthly_avg_mood['SentimentScore'].min()
y_max = monthly_avg_mood['SentimentScore'].max()



for idx, user_id in enumerate(users):
    row = idx // num_cols
    col = idx % num_cols

    user_data = monthly_avg_mood[monthly_avg_mood['user_id'] == user_id]
    axes[row, col].plot(user_data['month'], user_data['SentimentScore'], marker='o', linestyle='-', label=f'User ID: {user_id}')
    axes[row, col].set_title(f'User ID: {user_id} - Monthly Mood Graph')
    axes[row, col].set_xlabel('Month')
    axes[row, col].set_ylabel('Average Mood Score')
    axes[row, col].tick_params(axis='x', rotation=45)
    axes[row, col].set_ylim(y_min, y_max)
    axes[row, col].legend()

# Hide empty subplots if the number of users doesn't fill the entire grid
for idx in range(num_users, num_rows * num_cols):
    row = idx // num_cols
    col = idx % num_cols
    axes[row, col].axis('off')

plt.tight_layout()
plt.show()

# Finding user's favorite meal type based on Sentiment Score

# Finding the average meal type sentiment for each meal type for each user
meals_avg_sentiment = ranked_df.groupby(['user_id', 'meal_type'])['SentimentScore'].mean().reset_index()
max_sentiment_index = meals_avg_sentiment.groupby('user_id')['SentimentScore'].idxmax()
max_sentiment_meal_type = meals_avg_sentiment.loc[max_sentiment_index, ['user_id', 'meal_type', 'SentimentScore']]

print("Favorite Meal type for each user:")
print(max_sentiment_meal_type)

# Calculating daily user activity based on number of actions(logs) per day

user_activity = data_df.groupby(['user_id', 'date']).size().reset_index(name='actions_count')
user_activity_pivot = user_activity.pivot(index='date', columns='user_id', values='actions_count').fillna(0)

# Calculating monthly user activity based on number of actions(logs) per day

monthly_user_activity = data_df.groupby(['user_id', 'month']).size().reset_index(name='actions_count')
monthly_user_activity_pivot = monthly_user_activity.pivot(index='month', columns='user_id', values='actions_count').fillna(0)

# Plotting Monthly User Activity Graph

all_users = monthly_user_activity_pivot.columns.tolist()

num_users = len(all_users)
num_cols = 3
num_rows = -(-num_users // num_cols)

fig, axes = plt.subplots(num_rows, num_cols, figsize=(15, 5*num_rows))

# Scaling the Y-Axis
y_min = monthly_user_activity_pivot.min().min()
y_max = monthly_user_activity_pivot.max().max()



# Plotting bar charts for monthly user activity in a grid with set y-axis limits
for idx, user_id in enumerate(all_users):
    row = idx // num_cols
    col = idx % num_cols
    user_activity = monthly_user_activity_pivot[user_id]
    axes[row, col].bar(user_activity.index, user_activity.values, color='skyblue')
    axes[row, col].set_title(f'User ID: {user_id}')
    axes[row, col].set_xlabel('Month')
    axes[row, col].set_ylabel('Number of Actions')
    axes[row, col].set_ylim(y_min, y_max)

    axes[row, col].tick_params(axis='x', rotation=45)
    axes[row, col].grid(axis='y')
    axes[row, col].set_axisbelow(True)


# Hide empty subplots if the number of users doesn't fill the entire grid
for idx in range(num_users, num_rows * num_cols):
    row = idx // num_cols
    col = idx % num_cols
    axes[row, col].axis('off')

plt.tight_layout()
plt.show()